#pragma config(Hubs,  S1, MatrxRbtcs, none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_Matrix_S1_1, motorE,        tmotorMatrix, openLoop, reversed)
#pragma config(Motor,  mtr_Matrix_S1_2, motorF,        tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S1_3, motorG,        tmotorMatrix, openLoop, reversed)
#pragma config(Motor,  mtr_Matrix_S1_4, motorH,        tmotorMatrix, openLoop)
#pragma config(Servo,  srvo_Matrix_S1_1, servo1,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_2, servo2,               tServoStandard)
#pragma config(Servo,  srvo_Matrix_S1_3, servo3,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_4, servo4,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard           	    !!*//

/*
* teleop.c -- Logitech Dual Action Control
* Open an issue if anything needs to be added or changed
* ------------------------------------------------------------
* teleop.c utilizes "tank drive" -- Which means each joystick controls
* an individual motor.
* ------------------------------------------------------------
* ------------------------------------Config of Motors-----------------------------
*    [I/O Port]              [Name]              [Type]              [Description]
*    Port A									 motorA
*    Port B                  motorB              NXT                 Right motor
*    Port C                  motorC              NXT                 Left motor
* ---------------------------------------------------------------------------------
*/

#include "JoystickDriver.c"


void initcontrol(){
	  int threshold = 10;         /* Int 'threshold' will allow us to ignore low
                                    readings that keep our robot in perpetual motion.
                                    We need to tinker with the variable */

  while(true)                            // Infinite loop:
  {
    getJoystickSettings(joystick); // get joystick readings
    if(abs(joystick.joy1_y1) > threshold)   // If the right analog stick's Y-axis readings are either above or below the threshold:
    {
      motor[motorE] = joystick.joy1_y1;

    }
    else                                    // Else if the readings are within the threshold:
    {
      motor[motorE] = 0;

    }


    if(abs(joystick.joy1_y2) > threshold)   // If the left analog stick's Y-axis readings are either above or below the threshold:
    {
      motor[motorG] = -joystick.joy1_y2;
    }
    else                                    // Else if the readings are within the threshold:
    {
      motor[motorG] = 0;
    }

    if(joy1Btn(5) == 1){ //climber
    	motor[motorF] = 100;
    	motor[motorH] = 100;
  	}
  	else if(joy1Btn(6) == 1){
  		motor[motorF] = -100;
  		motor[motorH] = -100;
  	}
  	else{
  		motor[motorF] = 0;
  		motor[motorH] = 0;
  	}

  	if(joy1Btn(8) == 1){//dumper
 			servo[servo2] = 40;
  	}
  	else if(joy1Btn(7) == 1){
 			servo[servo2] = -40;
  	}
  	else{
  		servo[servo2] = 0;
  	}

  	if(joy1Btn(4) == 1){
  		motor[motorA] = 40;
  	}
  	else if(joy1Btn(2)){
  		motor[motorA] = -40;
  	}
  	else motor[motorA] = 0;


  }
}

task main()
{
	waitForStart();
	//autonomous
	initcontrol();
}
